<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Slackloop QC tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map {
            height: 95vh;
           
        }
        .highlight {
            color: red;
            font-weight: bold;
        }
        .custom-popup {
            max-height: 150px; /* Set the max height for the popup */
            overflow-y: auto; /* Enable vertical scrolling */
        }
        .legend {
            background-color: white;
            padding: 10px;
            line-height: 18px;
            color: #333;
            opacity: 0.7;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
        .legend .circle {
            border-radius: 50%; /* Make the shape round */
        }
    </style>
</head>
<body>
    <!--<h1>Upload GeoJSON Files to Display Points on Map</h1>-->
    <label for="fileInputId">Original Slackloop (geojson)</label>
    <input type="file" id="geojsonInput1" accept=".geojson">
    <label for="fileInputId">Plan Slackloop (geojson)</label>
    <input type="file" id="geojsonInput2" accept=".geojson">
    <!--<input type="file" id="geojsonInput3" accept=".geojson"> --> <!-- Added third GeoJSON input -->
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        // Initialize the map with scroll wheel zoom enabled and enhanced zoom options
        var map = L.map('map', {
            scrollWheelZoom: true, // Ensure scroll wheel zoom is enabled
            minZoom: 2, // Adjust the zoom delta to control how much zoom changes per scroll event
        }).setView([0, 0], 2); // Start with world view

        // Add a tile layer (basemap)
       L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '@ Develop by JGN',
            maxZoom: 99
        }).addTo(map);

        // Helper function to calculate distance between two latlng points in meters
        function calculateDistance(latlng1, latlng2) {
            return map.distance(latlng1, latlng2);
        }

        var geojsonData1 = null; // Data from the first GeoJSON
        var geojsonData2 = null; // Data from the second GeoJSON
        var geojsonData3 = null; // Data from the third GeoJSON

        var geojsonLayer1 = null; // Layer for the first GeoJSON
        var geojsonLayer3 = null;

        function processGeoJSON(fileInputId, callback) {
            var fileInput = document.getElementById(fileInputId);
            fileInput.addEventListener('change', function(event) {
                var file = event.target.files[0];
                var reader = new FileReader();
                reader.onload = function(e) {
                    var geojsonData = JSON.parse(e.target.result);
                    
                    if (fileInputId === 'geojsonInput1') {
                        geojsonData1 = geojsonData;
                        if (geojsonData2) {
                            updateMapWithCounts();
                        }
                        // Zoom to the location after uploading the first input
                        updateMapWithCounts();
                    } else if(fileInputId === 'geojsonInput2') {
                        geojsonData2 = geojsonData;
                        if (geojsonData1) {
                            updateMapWithCounts();
                        }
                    } /*else if (fileInputId === 'geojsonInput3') {
                        geojsonData3 = geojsonData;
                        showThirdGeoJSON();
                    }*/

                    // Invoke callback to handle the GeoJSON data if needed
                    if (callback) callback(geojsonData);
                };
                reader.readAsText(file);
            });
        }

        function updateMapWithCounts() {
            var coordCounts1 = {};
            var coordCounts2 = {};

            // Count occurrences of each coordinate pair for the first GeoJSON
            geojsonData1.features.forEach(function(feature) {
                var coords = feature.geometry.coordinates.join(',');
                coordCounts1[coords] = (coordCounts1[coords] || 0) + 1;
            });

            // Count occurrences of each coordinate pair for the second GeoJSON
            geojsonData2.features.forEach(function(feature) {
                var coords = feature.geometry.coordinates.join(',');
                coordCounts2[coords] = (coordCounts2[coords] || 0) + 1;
            });

            // Clear previous layer
            if (geojsonLayer1) map.removeLayer(geojsonLayer1);

            // Add the first GeoJSON layer to the map with counts
            geojsonLayer1 = L.geoJSON(geojsonData1, {
                pointToLayer: function (feature, latlng) {
                    var countWithinRadius = 0;
                    var coords = feature.geometry.coordinates.join(',');

                    // Count how many points from the second GeoJSON are within 30 feet
                    geojsonData2.features.forEach(function(otherFeature) {
                        var otherLatLng = L.latLng(otherFeature.geometry.coordinates[1], otherFeature.geometry.coordinates[0]);
                        if (calculateDistance(latlng, otherLatLng) <= 9.144) { // 30 feet ≈ 9.144 meters radius
                            countWithinRadius++;
                        }
                    });

                    var countSameCoords = coordCounts1[coords] || 0;

                    // Determine marker color based on the count comparison
                    var markerColor;

                    if (hasDuplicate) {
                        markerColor =  "orange",
                        surroundColor = "orange";
                    }else if (countWithinRadius > countSameCoords) {
                        markerColor = "yellow",
                        surroundColor = "f1ee8e"; // Yellow
                    } else if (countWithinRadius === countSameCoords) {
                        markerColor = "#a3f307",
                        surroundColor = "green"; // Fluorescent green
                    } else {
                        markerColor = "red",
                        surroundColor = "red"; // Red
                    }

                    var marker = L.circleMarker(latlng, {
                        radius: 8,
                        fillColor: markerColor,
                        color: surroundColor,
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                        //zIndex:1
                    });

                    // Collect properties from the second GeoJSON features within 30 feet
                    var popupContent = "Inserted slack count: " + (countWithinRadius > countSameCoords ? "<span class='highlight'>" + countWithinRadius + "</span>" : countWithinRadius) + "<br>Original slack count: " + countSameCoords + "<br>";

                    var parentVetroIdCounts = {}; // Track parent_vetro_id counts within this popup
                    var hasDuplicate = false; // Flag to determine if any parent_vetro_id is duplicated
                    geojsonData2.features.forEach(function(otherFeature) {
                        var otherLatLng = L.latLng(otherFeature.geometry.coordinates[1], otherFeature.geometry.coordinates[0]);
                        if (calculateDistance(latlng, otherLatLng) <= 9.144) { // 30 feet ≈ 9.144 meters radius
                            var parentVetroId = otherFeature.properties.parent_vetro_id || 'N/A';
                            var vetroId = otherFeature.properties.vetro_id || 'N/A';
                            
                            if (!parentVetroIdCounts[parentVetroId]) {
                                parentVetroIdCounts[parentVetroId] = 0;
                            }
                            parentVetroIdCounts[parentVetroId]++;
                           

                        
                            
                            if (parentVetroIdCounts[parentVetroId] > 1) {
                                hasDuplicate = true;
                            }

                            var coordinatesLink = "https://app.vetro.io/fibermap/map#25/" + otherFeature.geometry.coordinates[1] + "/" + otherFeature.geometry.coordinates[0];
                            var linkClass = (parentVetroIdCounts[parentVetroId] > 1) ? "highlight" : "";

                            // Highlight Coordinates based on the duplicate condition
                            var coordinatesStyle = parentVetroIdCounts[parentVetroId] > 1 ? "<span class='highlight'>" : "";
                            var coordinatesEndStyle = parentVetroIdCounts[parentVetroId] > 1 ? "</span>" : "";

                            popupContent += "<br>parent_vetro_id: " + (parentVetroIdCounts[parentVetroId] > 1 ? "<span class='highlight'>" + parentVetroId + "</span>" : parentVetroId);
                            //popupContent += "<br>vetro_id: " + (parentVetroIdCounts[parentVetroId] > 1 ? "<span class='highlight'>" + vetroId + "</span>":vetroId);
                            popupContent += "<br>Coordinates: " + coordinatesStyle + "[" + otherFeature.geometry.coordinates.join(', ') + "]" + coordinatesEndStyle;
                            popupContent += "<br><a class='" + linkClass + "' href='" + coordinatesLink + "' target='_blank'>View Location</a>" + "<br>";
                        }
                    });

                    // Change marker color to blue if duplicates are found
                    if (hasDuplicate&&countWithinRadius > countSameCoords) {
                        marker.setStyle({
                            fillColor: "yellow", // Blue
                            color: "yellow"
                        });
                    }
                    else if (hasDuplicate) {
                        marker.setStyle({
                            fillColor: "blue", // Blue
                            color: "blue"
                        });
                    }

                    marker.bindPopup("<div class='custom-popup'>" + popupContent + "</div>");
                    return marker;
                }
            }).addTo(map);

            // Fit map bounds to include only the points from the first GeoJSON
            if (geojsonData1.features.length > 0) {
                var bounds = L.featureGroup([geojsonLayer1]).getBounds();
                map.fitBounds(bounds);
            }
        }

        function showThirdGeoJSON() {
            if (geojsonLayer3) map.removeLayer(geojsonLayer3);

            geojsonLayer3 = L.geoJSON(geojsonData3, {
                style: function (feature) {
                    return {
                        color: "green",
                        weight: 2,
                        opacity: 1,
                        zIndex: 0 
                    };
                }
            }).addTo(map);

            
                var bounds = L.featureGroup([geojsonLayer3]).getBounds();
                map.fitBounds(bounds);
            
        }

        var legend = L.control({ position: 'bottomright' });

        legend.onAdd = function(map) {
            var div = L.DomUtil.create('div', 'legend');
            div.innerHTML += '<i class="circle" style="background: #a3f307"></i> Slackloop Pass<p>';
            div.innerHTML += '<i class="circle" style="background: yellow"></i>Over inserted Slackloop<p>';
            div.innerHTML += '<i class="circle" style="background: red"></i> Missing Slackloop<p>';
            div.innerHTML += '<i class="circle" style="background: blue"></i> Duplicate Slackloop';
            //div.innerHTML += '<i class="circle" style="background: red"></i> Missing Slackloop<p>';
            return div;
        };

        legend.addTo(map);

        // Process both GeoJSON inputs
        //processGeoJSON('geojsonInput3');
        processGeoJSON('geojsonInput1');
        processGeoJSON('geojsonInput2');
        
        
    </script>
</body>
</html>
